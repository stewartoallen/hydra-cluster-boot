var path = require('path');
var swig = require('swig');
var url = require('url');
var fs = require('fs');
var server = null;
var db = null;
var ctype = {};
var template = {};
var waiters = {};
var clusterDefault = {};

/**
 * TODO
 *
 * check image date/size/md5sum ? each time and stop/download/unzip ?
 * add curl boot to hcl (hcl remote start)
 */

var http = {
    handle : function(req, res) {
        console.log(['request',req.method, req.url]);
        if (!(req.method == 'GET' || req.method == 'POST')) {
            return http.fail(res);
        }
        var purl = url.parse(req.url, true);

        var func = complete[purl.pathname];
        if (func) return func(req, res, purl);

        for (var key in prefix) {
            if (purl.pathname.indexOf(key) == 0) {
                return prefix[key](req, res, purl);
            }
        }

        http.fail(res, "no valid target", 404);
    },

    sendFile : function(res, filename) {
        try {
            var filePath = ["config","image",filename].join('/');
            var contentType = ctype[filename.substring(filename.lastIndexOf('.'))] || "application/octet-stream";
            var contentLength = fs.statSync(filePath).size;
            res.writeHead(200, {
                'Content-Type' : contentType,
                'Content-Length' : contentLength
            });
            fs.createReadStream(filePath).pipe(res);
        } catch (error) {
            http.fail(res, error, 500);
        }
    },

    template : function(res, templateName, values) {
        swig.renderFile(templateName, values, function(err, output) {
            if (err) return http.fail(res, err, 500);
            return http.ok(res, output);
        });
    },

    ok : function(res, msg) {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end(typeof msg == 'string' ? msg : JSON.stringify(msg)+"\n");
    },

    fail : function(res, msg, code) {
        res.writeHead(code | 404, {'Content-Type': 'text/plain'});
        res.end((typeof msg == "string" ? msg : "unsupported request "+msg) + "\n");
    }
};


var config = {
    key : function(arr) {
        return ["config",arr.join('-')].join('/');
    },

    get : function(arr, options, callback) {
        fs.readFile(config.key(arr), options, callback);
    },

    put : function(arr, val, options, callback) {
        fs.writeFile(config.key(arr), val, options, callback);
    },

    getJS : function(arr, callback) {
        config.get(arr, null, function(err, data) {
            if (err) return callback(err);
            callback(null, eval(["(",data,")"].join("")));
        });
    },

    putJS : function(arr, val, callback) {
        config.put(arr, JSON.stringify(val,null,"  "), callback);
    }
};

var complete = {
    "/help" : function(req, res, url) {
        return http.ok(res, [
            "/api/list_clusters", "/api/create_cluster", "/api/get_cluster", "/api/delete_cluster", "/api/boot_node"
        ]);
    }
};

var prefix = {
    "/api/" : function(req, res, url) {
        var funcName = url.pathname.substring(5);
        var func = api[funcName];
        if (typeof func == 'undefined') {
            return http.fail(res, "invalid api endpoint '"+funcName+"'");
        }
        func(url.query, req.socket.remoteAddress, function(err, obj) {
            if (err) {
                http.fail(res, err);
            } else {
                http.ok(res, obj);
            }
        });
    },
    "/image/" : function(req, res, url) {
        return http.sendFile(res, url.pathname.substring(7));
    },
    "/render/" : function(req, res, url) {
        var funcName = url.pathname.substring(8);
        var func = render[funcName];
        if (!func) return http.template(res, url.pathname.substring(8), url.query);
        var q = url.query;
        if (!q.cluster) {
            return http.fail(res, 'missing "cluster" parameter', 404);
        }
        q.hostname = q.hostname || req.socket.remoteAddress;
        if (!q.hostname) {
            return http.fail(res, 'missing "hostname" parameter', 404);
        }
        config.getJS(['cluster', q.cluster], function(err, cluster) {
            if (err) return http.fail(res, 'invalid cluster '+ q.cluster);
            setDefaults(clusterDefault, cluster);
            if (cluster.shortenHost) {
                q.hostname = shortenHost(q.hostname);
            }
            q.funcName = funcName;
            config.getJS(['cluster', q.cluster, 'host', q.hostname], function(err, host) {
                func(res, q, cluster, host);
            });
        });
    }
};

var render = {
    "boot" : function(res, query, cluster, host) {
        http.template(res, query.funcName, {
            version: query.version || 'default',
            cluster: query.cluster,
            hostname: query.hostname
        });
    },

    "boot_two" : function(res, query, cluster, host) {
        if (!host) return http.fail(res, 'invalid host '+ query.hostname);
        if (!host.process) return http.fail(res, 'host missing process list');
        var proc = [];
        for (var key in host.process) proc.push(key);
        http.template(res, query.funcName, {
            version: query.version || 'default',
            cluster: query.cluster,
            hostname: query.hostname,
            process: proc.join(' ')
        });
    },

    "boot-mesh" : function(res, query, cluster, host) {
        http.template(res, query.funcName, {
            mesh_opt: cluster.config.mesh.cmdline,
            mesh_port: cluster.config.mesh.port || 5000
        });
    },

    "boot-spawn" : function(res, query, cluster, host) {
        http.template(res, query.funcName, {
            spawn_opt: cluster.config.spawn.cmdline
        });
    },

    "boot-minion" : function(res, query, cluster, host) {
        http.template(res, query.funcName, {
            minion_opt: cluster.config.minion.cmdline
        });
    },

    "boot-qmaster" : function(res, query, cluster, host) {
        http.template(res, query.funcName, {
            qmaster_opt: cluster.config.qmaster.cmdline
        });
    },

    "boot-qworker" : function(res, query, cluster, host) {
        http.template(res, query.funcName, {
            qworker_opt: cluster.config.qworker.cmdline
        });
    }
};

var shortenHost = function(hostname) {
    var newhost = hostname.split(".")[0];
    return (Number.isNaN(parseInt(newhost))) ? newhost : hostname;
};

var getKeys = function(o) {
    var keys = [];
    for (var key in o) keys.push(key);
    return keys;
};

var countKeys = function(o) {
    return getKeys(o).length;
};

var setDefaults = function(oS, oT) {
    for (var key in oS) {
        if (!oT[key]) oT[key] = oS[key];
    }
};

var api = {
    wait_nodes : function(query, remote, callback) {
        if (!query.cluster) callback("missing cluster");
        if (!query.key) callback("missing key");
        config.getJS(['cluster',query.cluster], function(err, cluster) {
            if (err) callback(err);
            var target = cluster.template[query.key];
            if (typeof target == 'undefined') callback("invalid target key '"+query.key+"'");
            if (!cluster.node || !cluster.node[query.key] || countKeys(cluster.node[query.key]) < target) {
                var wait_key = [query.cluster,query.key].join('_');
                if (!waiters[wait_key]) {
                    waiters[wait_key] = [];
                }
                waiters[wait_key].push({target:target,callback:callback});
            } else {
                callback(null, getKeys(cluster.node[query.key]).join(" "));
            }
        });
    },

    register_node : function(query, remote, callback) {
        if (!query.hostname) callback("missing hostname");
        if (!query.cluster) callback("missing cluster");
        if (!query.key) callback("missing key");
        var hostname = query.hostname;
        var dbkey = ['cluster',query.cluster];
        config.getJS(dbkey, function(err, cluster) {
            if (err) callback(err);
            setDefaults(clusterDefault, cluster);
            var target = cluster.template[query.key];
            if (typeof target == 'undefined') callback("invalid target key '"+query.key+"'");
            var wait_key = [query.cluster,query.key].join('_');
            if (!cluster.node) {
                cluster.node = {};
            }
            if (!cluster.node[query.key]) {
                cluster.node[query.key] = {};
            }
            if (cluster.shortenHost) {
                hostname = shortenHost(hostname);
            }
            if (!cluster.node[query.key][hostname]) {
                var waiting = waiters[wait_key];
                if (waiting) {
                    var key_hosts = cluster.node[query.key];
                    var keys = [];
                    for (var key in key_hosts) {
                        keys.push(key);
                    }
                    var notified = 0;
                    for (var i=0; i<waiting.length; i++) {
                        if (!waiting[i]) {
                            notified++;
                            continue;
                        }
                        if (waiting[i].target <= keys.length) {
                            waiting[i].callback(null, keys.join(" "));
                            waiting[i] = null;
                            notified++;
                        }
                    }
                    if (notified == waiting.length) {
                        delete waiters[wait_key];
                    }
                }
            }
            var conf = cluster.node[query.key][hostname] = {ip:remote,config:query.config,updated:new Date().getTime()};
            config.putJS(dbkey, cluster, function(err) {
                if (err) throw err;
            });
            callback(null,{node:conf});
        });
    },

    db_load : function(query, remote, callback) {
        if (remote != "127.0.0.1") {
            return callback("not authorized");
        }
        exports.load();
        callback(null,{load:"success"});
    },

    db_dump : function(query, remote, callback) {
        if (remote != "127.0.0.1") {
            return callback("not authorized");
        }
        exports.dump();
        callback(null,{dump:"success"});
    },

    create_cluster : function(query, remote, callback) {
        var id = require('uuid').v1().replace(/-/g,'');
        var key = ['cluster',id];
        config.getJS(key, function(err, val) {
            if (err) {
                config.putJS(key, {template:query}, function(err) {
                    if (err) {
                        callback("db put fail");
                    } else {
                        callback(null, {cluster:id});
                    }
                });
            } else {
                callback("db key exists");
            }
        });
    },

    get_cluster : function(query, remote, callback) {
        var key = ['cluster',query.id];
        config.getJS(key, function(err, val) {
            if (err) {
                callback(err);
            } else {
                callback(null,val);
            }
        });
    }
};

var exports = {
    init : function(port) {
        if (server != null) {
            throw "server already initialized"
        }
        swig.setDefaults({ loader: swig.loaders.fs('config/template' ), cache: false });
        server = require('http').createServer(function (req, res) {
            http.handle(req, res);
        }).listen(port | 8008);
        config.getJS(['cluster', "defaults"], function(err, cluster) {
            if (!err && cluster) {
                setDefaults(cluster, clusterDefault);
            }
        });
    }
};

module.exports = exports;
