var uuid = require('node-uuid');
var level = require('levelup');
var http = require('http');
var url = require('url');
var server = null;
var db = null;

var httpHandle = function(req, res) {
    console.log(['request',req.method, req.url]);
    if (!(req.method == 'GET' || req.method == 'POST')) {
        return httpFail(res);
    }
    if (req.url == "/help") {
        return httpOK(res, [
            "/api/list_clusters", "/api/create_cluster", "/api/get_cluster", "/api/delete_cluster", "/api/boot_node"
        ]);
    }
    if (!(req.url.indexOf("/api/") == 0)) {
        return httpFail(res, "unsupported request: "+req.url+"\ntry /help");
    }
    var purl = url.parse(req.url, true);
    var funcName = purl.pathname.substring(5);
    var func = api[funcName];
    if (typeof func == 'undefined') {
        return httpFail(res, "invalid api endpoing '"+funcName+"'");
    }
    func(purl.query, req.socket.remoteAddress, function(err, obj) {
        if (err) {
            httpFail(res, err);
        } else {
            httpOK(res, obj);
        }
    });
};

var httpSend = function(res, key, template) {
    get(key, function(err, data) {
        if (!err) {
            httpOK(res, data);
        } else {
            httpFail(res, err, 500);
        }
    });
};

var httpOK = function(res, msg) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end(typeof msg == 'string' ? msg : JSON.stringify(msg)+"\n");
};

var httpFail = function(res, msg, code) {
    res.writeHead(code | 404, {'Content-Type': 'text/plain'});
    res.end((typeof msg == "string" ? msg : "unsupported request "+msg) + "\n");
};

var key = function (arr) {
    return arr.join('-');
};

var get = function(arr, options, callback) {
    db.get(key(arr), options, callback);
};

var put = function(arr, val, options, callback) {
    db.put(key(arr), val, options, callback);
};

var getJS = function(arr, callback) {
    return get(arr, {valueEncoding:"json"}, callback)
};

var putJS = function(arr, val, callback) {
    db.put(arr, val, {valueEncoding:"json"}, callback);
};

var api = {
    boot_node : function(query, remote, callback) {
        console.log(['boot node',query,remote]);
        /**
         * TODO
         * use host IP to find config record
         * otherwise use cluster id param and an identity array param
         * return templated boot script
         */
        if (query.cluster && query.process) {
            callback(null, 'boot using '+query.cluster+" & "+query.process);
        } else {
            getJS(['host',remote], function(err, val) {
                if (err) return callback(err);
                callback(null, val);
            });
        }
    },

    list_clusters : function(query, remote, callback) {
        var keys = [];
        var stream = db.createKeyStream({start:"cluster-"})
            .on('data', function(data) {
                if (!data.indexOf("cluster-") == 0) {
                    callback(null, keys);
                    stream.destroy();
                } else {
                    keys.push(data.substring(8));
                }
            })
            .on('end', function() {
                callback(null, keys);
            });
    },

    create_cluster : function(query, remote, callback) {
        var id = uuid.v1().replace(/-/g,'');
        var key = ['cluster',id];
        getJS(key, function(err, val) {
            if (err) {
                putJS(key, {template:query}, function(err) {
                    if (err) {
                        callback("db put fail");
                    } else {
                        callback(null, {cluster:id});
                    }
                });
            } else {
                callback("db key exists");
            }
        });
    },

    get_cluster : function(query, remote, callback) {
        var key = ['cluster',query.id];
        getJS(key, function(err, val) {
            if (err) {
                callback(err);
            } else {
                callback(null,val);
            }
        });
    },

    delete_cluster : function(query, remote, callback) {
        var keys = [];
        var start = key(['cluster',query.id]);
        var stream = db.createKeyStream({start:start})
            .on('data', function(data) {
                if (!data.indexOf(start) == 0) {
                    callback(null, keys);
                    stream.destroy();
                } else {
                    keys.push(data);
                    db.del(data);
                }
            })
            .on('end', function() {
                callback(null, keys);
            });
    }
};

var exports = {
    init : function(port) {
        if (server != null) {
            throw "server already initialized"
        }
        server = http.createServer(function (req, res) {
            httpHandle(req, res);
        }).listen(port | 8008);
        db = level('cluster.db');
    },

    dump : function(dir) {
        var dir = dir || 'cluster.dump';
        var fs = require('fs');
        try {
            fs.mkdirSync(dir);
        } catch (err) {
            console.log(err);
        }
        db = level('cluster.db');
        db.createReadStream()
            .on('data', function(data) {
                var key = data.key;
                var val = data.value;
                fs.writeFileSync([dir,key].join('/'), val);
            })
            .on('end', function() {
                db.close();
            });
    },

    load : function(dir) {
        var dir = dir || 'cluster.dump';
        var fs = require('fs');
        var dirInfo = fs.statSync(dir);
        db = level('cluster.db');
        db.createWriteStream()
            .on('error', function(err) {
                throw err;
            })
            .on('end', function() {
                db.close();
            });
        var files = fs.readdirSync(dir);
        for (var i=0; i<files.length; i++) {
            var data = fs.readFileSync([dir,files[i]].join('/'));
            db.put(files[i], data);
        }
        db.close();
    }
};

module.exports = exports;
