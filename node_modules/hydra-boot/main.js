var level = require('levelup');
var path = require('path');
var swig = require('swig');
var url = require('url');
var fs = require('fs');
var server = null;
var db = null;
var ctype = {};
var template = {};
var waiters = {};
var localTest = true;

var http = {
    handle : function(req, res) {
        console.log(['request',req.method, req.url]);
        if (!(req.method == 'GET' || req.method == 'POST')) {
            return http.fail(res);
        }
        var purl = url.parse(req.url, true);

        var func = complete[purl.pathname];
        if (func) return func(req, res, purl);

        for (var key in prefix) {
            if (purl.pathname.indexOf(key) == 0) {
                return prefix[key](req, res, purl);
            }
        }

        http.fail(res, "no valid target", 404);
    },

    sendFile : function(res, filename) {
        try {
            var filePath = ["image",filename].join('/');
            var contentType = ctype[filename.substring(filename.lastIndexOf('.'))] || "application/octet-stream";
            var contentLength = fs.statSync(filePath).size;
            res.writeHead(200, {
                'Content-Type' : contentType,
                'Content-Length' : contentLength
            });
            fs.createReadStream(filePath).pipe(res);
        } catch (error) {
            http.fail(res, error, 500);
        }
    },

    template : function(res, templateName, values) {
        swig.renderFile(templateName, values, function(err, output) {
            if (err) return http.fail(res, err, 500);
            return http.ok(res, output);
        });
    },

    ok : function(res, msg) {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end(typeof msg == 'string' ? msg : JSON.stringify(msg)+"\n");
    },

    fail : function(res, msg, code) {
        res.writeHead(code | 404, {'Content-Type': 'text/plain'});
        res.end((typeof msg == "string" ? msg : "unsupported request "+msg) + "\n");
    }
};


var config = {
    key : function (arr) {
        return arr.join('-');
    },

    get : function(arr, options, callback) {
        db.get(config.key(arr), options, callback);
    },

    put : function(arr, val, options, callback) {
        db.put(config.key(arr), val, options, callback);
    },

    getJS : function(arr, callback) {
        return config.get(arr, {valueEncoding:"json"}, callback)
    },

    putJS : function(arr, val, callback) {
        db.put(config.key(arr), val, {valueEncoding:"json"}, callback);
    }
};

var configFile = {
    key : function(arr) {
        return ["cluster.dump",arr.join('-')].join('/');
    },

    get : function(arr, options, callback) {
        fs.readFile(configFile.key(arr), options, callback);
    },

    put : function(arr, val, options, callback) {
        fs.writeFile(configFile.key(arr), val, options, callback);
    },

    getJS : function(arr, callback) {
        configFile.get(arr, null, function(err, data) {
            if (err) return callback(err);
            callback(null, JSON.parse(data));
        });
    },

    putJS : function(arr, val, callback) {
        configFile.put(arr, JSON.stringify(val), callback);
    }
};

if (localTest) config = configFile;

var complete = {
    "/help" : function(req, res, url) {
        return http.ok(res, [
            "/api/list_clusters", "/api/create_cluster", "/api/get_cluster", "/api/delete_cluster", "/api/boot_node"
        ]);
    }
};

var prefix = {
    "/api/" : function(req, res, url) {
        var funcName = url.pathname.substring(5);
        var func = api[funcName];
        if (typeof func == 'undefined') {
            return http.fail(res, "invalid api endpoint '"+funcName+"'");
        }
        func(url.query, req.socket.remoteAddress, function(err, obj) {
            if (err) {
                http.fail(res, err);
            } else {
                http.ok(res, obj);
            }
        });
    },
    "/image/" : function(req, res, url) {
        return http.sendFile(res, url.pathname.substring(7));
    },
    "/render/" : function(req, res, url) {
        var func = render[url.pathname.substring(8)];
        if (func) return func(req, res, url);
        return http.template(res, url.pathname.substring(8), url.query);
    }
};

var render = {
    boot : function(req, res, url) {
        var q = url.query;
        if (!q.cluster) {
            return http.fail(res, 'missing "cluster" parameter', 404);
        }
        var hostname = q.hostname || req.socket.remoteAddress;
        if (!hostname) {
            return http.fail(res, 'missing "hostname" parameter', 404);
        }
        config.getJS(['cluster', q.cluster], function(err, cluster) {
            if (err) return http.fail(res, 'invalid cluster '+ q.cluster);
            config.getJS(['cluster', q.cluster, 'host', hostname], function(err, host) {
                if (err) return http.fail(res, 'invalid host '+ hostname);
                if (!host.process) return http.fail(res, 'host missing process list');
                var proc = [];
                for (var key in host.process) proc.push(key);
                http.template(res, "boot", {
                    version: q.version || 'default',
                    cluster: q.cluster,
                    hostname: hostname,
                    process: proc.join(' ')
                });
            });
        });
    }
};

var countKeys = function(o) {
    var keys = [];
    for (var key in o) keys.push(key);
    return keys.length;
}

var getKeys = function(o) {
    var keys = [];
    for (var key in o) keys.push(key);
    return keys;
}
var api = {
    wait_nodes : function(query, remote, callback) {
        if (!query.cluster) callback("missing cluster");
        if (!query.key) callback("missing key");
        config.getJS(['cluster',query.cluster], function(err, cluster) {
            if (err) callback(err);
            var target = cluster.template[query.key];
            if (typeof target == 'undefined') callback("invalid target key '"+query.key+"'");
            if (!cluster.node || !cluster.node[query.key] || countKeys(cluster.node[query.key]) < target) {
                var wait_key = [query.cluster,query.key].join('_');
                if (!waiters[wait_key]) {
                    waiters[wait_key] = [];
                }
                waiters[wait_key].push({target:target,callback:callback});
            } else {
                callback(null, getKeys(cluster.node[query.key]).join(" "));
            }
        });
    },

    register_node : function(query, remote, callback) {
        if (!query.hostname) callback("missing hostname");
        if (!query.cluster) callback("missing cluster");
        if (!query.key) callback("missing key");
        var dbkey = ['cluster',query.cluster];
        config.getJS(dbkey, function(err, cluster) {
            if (err) callback(err);
            var target = cluster.template[query.key];
            if (typeof target == 'undefined') callback("invalid target key '"+query.key+"'");
            var wait_key = [query.cluster,query.key].join('_');
            if (!cluster.node) {
                cluster.node = {};
            }
            if (!cluster.node[query.key]) {
                cluster.node[query.key] = {};
            }
            if (!cluster.node[query.key][query.hostname]) {
                var waiting = waiters[wait_key];
                if (waiting) {
                    var key_hosts = cluster.node[query.key];
                    var keys = [];
                    for (var key in key_hosts) {
                        keys.push(key);
                    }
                    var notified = 0;
                    for (var i=0; i<waiting.length; i++) {
                        if (!waiting[i]) {
                            notified++;
                            continue;
                        }
                        if (waiting[i].target <= keys.length) {
                            waiting[i].callback(null, keys.join(" "));
                            waiting[i] = null;
                            notified++;
                        }
                    }
                    if (notified == waiting.length) {
                        delete waiters[wait_key];
                    }
                }
            }
            var conf = cluster.node[query.key][query.hostname] = {ip:remote,config:query.config,updated:new Date().getTime()};
            config.putJS(dbkey, cluster, function(err) {
                if (err) throw err;
            });
            callback(null,{node:conf});
        });
    },

    db_load : function(query, remote, callback) {
        if (remote != "127.0.0.1") {
            return callback("not authorized");
        }
        exports.load();
        callback(null,{load:"success"});
    },

    db_dump : function(query, remote, callback) {
        if (remote != "127.0.0.1") {
            return callback("not authorized");
        }
        exports.dump();
        callback(null,{dump:"success"});
    },

    list_clusters : function(query, remote, callback) {
        var keys = [];
        var stream = db.createKeyStream({start:"cluster-"})
            .on('data', function(data) {
                if (!data.indexOf("cluster-") == 0) {
                    callback(null, keys);
                    stream.destroy();
                } else {
                    keys.push(data.substring(8));
                }
            })
            .on('end', function() {
                callback(null, keys);
            });
    },

    create_cluster : function(query, remote, callback) {
        var id = require('uuid').v1().replace(/-/g,'');
        var key = ['cluster',id];
        config.getJS(key, function(err, val) {
            if (err) {
                config.putJS(key, {template:query}, function(err) {
                    if (err) {
                        callback("db put fail");
                    } else {
                        callback(null, {cluster:id});
                    }
                });
            } else {
                callback("db key exists");
            }
        });
    },

    get_cluster : function(query, remote, callback) {
        var key = ['cluster',query.id];
        config.getJS(key, function(err, val) {
            if (err) {
                callback(err);
            } else {
                callback(null,val);
            }
        });
    },

    delete_cluster : function(query, remote, callback) {
        var keys = [];
        var start = config.key(['cluster',query.id]);
        var stream = db.createKeyStream({start:start})
            .on('data', function(data) {
                if (!data.indexOf(start) == 0) {
                    callback(null, keys);
                    stream.destroy();
                } else {
                    keys.push(data);
                    db.del(data);
                }
            })
            .on('end', function() {
                callback(null, keys);
            });
    }
};

var exports = {
    init : function(port) {
        if (server != null) {
            throw "server already initialized"
        }
        swig.setDefaults({loader:{
            resolve : function(to, from) {
                return to;
            },
            load : function(ident, callback) {
                var value = template[ident];
                if (callback) return callback(value == null ? "missing template "+ident : null, value);
                if (value == null) throw "missing template "+ident;
                return value;
            }
        }});
        server = require('http').createServer(function (req, res) {
            http.handle(req, res);
        }).listen(port | 8008);
        db = level('cluster.db');
        if (localTest) {
            console.log(">> LOCAL TEST MODE <<");
            exports.load();
        }
        var read = db.createReadStream({start:"template-"})
            .on("data", function(data) {
                if (!data.key.indexOf("template-") == 0) return read.detroy();
                template[data.key.substring(9)] = data.value;
            });
    },

    dump : function(dir) {
        var dir = dir || 'cluster.dump';
        try {
            fs.stat(dir, function(err, stats) {
                if (err) fs.mkdirSync(dir);
            });
        } catch (err) {
            console.log(err);
        }
        var close = !db;
        db = db || level('cluster.db');
        db.createReadStream()
            .on('data', function(data) {
                var key = data.key;
                var val = data.value;
                fs.writeFileSync([dir,key].join('/'), val);
            })
            .on('end', function() {
                if (close) db.close();
            });
    },

    load : function(dir) {
        var dir = dir || 'cluster.dump';
        var dirInfo = fs.statSync(dir);
        var close = !db;
        db = db || level('cluster.db');
        db.createWriteStream()
            .on('error', function(err) {
                throw err;
            })
            .on('end', function() {
                db.close();
            });
        var files = fs.readdirSync(dir);
        for (var i=0; i<files.length; i++) {
            var data = fs.readFileSync([dir,files[i]].join('/'));
            console.log(['db.load', files[i]]);
            db.put(files[i], data);
        }
        if (close) db.close();
    }
};

module.exports = exports;
